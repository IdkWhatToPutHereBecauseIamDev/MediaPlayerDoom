<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Doom: Windows Media Controls Edition</title>

    <meta property="og:title" content="Doom: Windows Media Controls Edition">
    <meta property="og:description" content="Play a tiny doom-like shooter inside your Windows Media Controls overlay. Use Prev/Next to turn, Pause to FIRE!">
    <meta property="og:image" content="https://thegoodjakeward.github.io/snake_windows_media_controls_edition/social.png">
    <meta property="og:url" content="https://thegoodjakeward.github.io/snake_windows_media_controls_edition/">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="https://thegoodjakeward.github.io/snake_windows_media_controls_edition/">
    <meta name="twitter:title" content="Doom: Windows Media Controls Edition">
    <meta name="twitter:description" content="Play a tiny doom-like shooter inside your Windows Media Controls overlay. Use Prev/Next to turn, Pause to FIRE!">
    <meta name="twitter:image" content="https://thegoodjakeward.github.io/snake_windows_media_controls_edition/social.png">
    
    <style>
        body { 
            background: #111; 
            color: #eee; 
            font-family: 'Segoe UI', sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            height: 100vh; 
            margin: 0; 
        }
        
        h1 {
            margin: 0 0 20px 0;
            font-weight: 300;
            letter-spacing: 2px;
            color: #f40;
            text-transform: uppercase;
            text-align:center;
            text-shadow: 0 0 10px rgba(255, 64, 0, 0.25);
        }

        .panel {
            background: #222;
            padding: 2rem;
            border-radius: 8px;
            border: 1px solid #444;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            width: 420px;
        }

        button { 
            padding: 12px 20px; 
            font-size: 16px; 
            cursor: pointer; 
            background: #f40; 
            color: #000;
            border: none; 
            font-weight: bold; 
            border-radius: 4px; 
            margin-bottom: 12px;
            width: 100%;
        }
        button:hover { background: #d13a00; }
        button:disabled { background: #444; color: #888; cursor: not-allowed; }

        .settings-group {
            margin: 10px 0;
            text-align: left;
        }

        label { display: block; margin-bottom: 5px; font-weight: bold; }
        
        select, input[type=range] {
            width: 100%;
            padding: 8px;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            margin-bottom: 8px;
            box-sizing: border-box;
        }

        .slider-container {
            margin-top: 10px;
            text-align: left;
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #444;
        }

        .instructions { font-size: 0.9em; color: #aaa; margin-top: 12px; line-height: 1.5; }
    </style>
</head>
<body>

    <h1>Doom: Windows Media <br/>Controls Edition</h1>

    <div class="panel">
        <button id="startBtn">INITIALIZE SYSTEM LINK</button>
        
        <div class="settings-group">
            <label for="difficulty">Difficulty Level:</label>
            <select id="difficulty">
                <option value="casual" selected>Casual (8x8 Arena - Easier)</option>
                <option value="gamer">Gamer (16x16 Arena - Harder)</option>
            </select>

            <label for="weapon">Selected Gun:</label>
            <select id="weapon">
                <option value="pistol" selected>Pistol — hits first enemy (1 dmg)</option>
                <option value="shotgun">Shotgun — short cone, multiple hits (1 dmg)</option>
                <option value="sniper">Sniper — long range, high damage (3 dmg)</option>
            </select>
        </div>

        <div class="slider-container">
            <label for="bgSlider">Background Shade</label>
            <div style="font-size: 0.8em; color: #888; margin-bottom: 5px;">
                Use slider to tune the arena background shade.
            </div>
            <input type="range" id="bgSlider" min="0" max="255" value="0">
        </div>

        <div class="instructions">
            <p>1. Click Initialize above.</p>
            <p>2. Press <b>Win + A</b> to open Media Controls.</p>
            <p>3. Press <b>Prev (&#9198;)</b> or <b>Next (&#9197;)</b> to TURN left/right.</p>
            <p>4. Press <b>Pause</b> to FIRE with the selected gun.</p>
        </div>
    </div>

    <audio id="bgMusic" loop src="music.mp3"></audio>

    <script>
        // --- SETUP ---
        const canvas = document.createElement('canvas'); // offscreen canvas for artwork
        canvas.width = 256;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');
        
        const startBtn = document.getElementById('startBtn');
        const music = document.getElementById('bgMusic');
        const difficultySelect = document.getElementById('difficulty');
        const weaponSelect = document.getElementById('weapon');
        const bgSlider = document.getElementById('bgSlider');

        // Game State Variables
        let gameState = 'MENU'; 
        let highScore = 0;
        let score = 0;
        let player = null;
        let enemies = []; // {x,y,hp}
        let gameOverTime = 0; // Timestamp for death
        
        // Settings
        let tileCount = 8; 
        let gridSize = 32;
        let bgGrayValue = 0; // 0-255
        let gameSpeed = 1000 / 6;
        let enemyCount = 3;

        // --- INPUTS ---
        difficultySelect.onchange = () => {
            if (gameState === 'PLAYING') {
                gameState = 'GAMEOVER';
            } else {
                setDifficulty(); 
            }
        };

        bgSlider.oninput = () => {
            bgGrayValue = parseInt(bgSlider.value);
            draw();
            updateOverlay();
        };

        function setDifficulty() {
            const level = difficultySelect.value;
            if (level === 'casual') {
                tileCount = 8;
                gameSpeed = 1000 / 6;
                enemyCount = 3;
            } else if (level === 'gamer') {
                tileCount = 16;
                gameSpeed = 1000 / 8;
                enemyCount = 7;
            }
            gridSize = canvas.width / tileCount;
        }

        function resetGame() {
            setDifficulty();
            const mid = Math.floor(tileCount / 2);
            player = {x: mid, y: mid, dir: 0}; // dir: 0=right,1=down,2=left,3=up
            enemies = [];
            score = 0;
            placeEnemies(enemyCount);
            gameState = 'PLAYING';
            draw();
            updateOverlay();
        }

        function placeEnemies(n) {
            enemies = [];
            let attempts = 0;
            while (enemies.length < n && attempts < 1000) {
                const ex = Math.floor(Math.random() * tileCount);
                const ey = Math.floor(Math.random() * tileCount);
                if (ex === player.x && ey === player.y) { attempts++; continue; }
                let conflict = enemies.some(e => e.x === ex && e.y === ey);
                if (!conflict) {
                    // set hp based on difficulty
                    const hp = difficultySelect.value === 'gamer' ? (Math.random() < 0.4 ? 2 : 1) : 1;
                    enemies.push({x: ex, y: ey, hp});
                }
                attempts++;
            }
        }

        // --- RAYCAST + WEAPONS ---
        function raycast(origX, origY, dir, range) {
            const dx = dir === 0 ? 1 : dir === 2 ? -1 : 0;
            const dy = dir === 1 ? 1 : dir === 3 ? -1 : 0;
            for (let step = 1; step <= range; step++) {
                const tx = origX + dx * step;
                const ty = origY + dy * step;
                if (tx < 0 || tx >= tileCount || ty < 0 || ty >= tileCount) break;
                const idx = enemies.findIndex(e => e.x === tx && e.y === ty);
                if (idx !== -1) return {index: idx, x: tx, y: ty, step};
            }
            return null;
        }

        // Cone check for shotgun (front cone of width)
        function shotgunHits(origX, origY, dir, range) {
            const hits = new Set();
            // For grid-based cone, check tiles within Manhattan distance <= range where the primary direction coordinate increases
            for (let step = 1; step <= range; step++) {
                // generate lateral offsets for a small cone
                const offsets = [];
                if (dir === 0 || dir === 2) { // horizontal
                    const sx = (dir === 0 ? 1 : -1) * step;
                    for (let lateral = -step; lateral <= step; lateral++) {
                        offsets.push({x: origX + sx, y: origY + lateral});
                    }
                } else { // vertical
                    const sy = (dir === 1 ? 1 : -1) * step;
                    for (let lateral = -step; lateral <= step; lateral++) {
                        offsets.push({x: origX + lateral, y: origY + sy});
                    }
                }
                for (const pos of offsets) {
                    if (pos.x < 0 || pos.x >= tileCount || pos.y < 0 || pos.y >= tileCount) continue;
                    const idx = enemies.findIndex(e => e.x === pos.x && e.y === pos.y);
                    if (idx !== -1) hits.add(idx);
                }
            }
            return Array.from(hits).map(i => ({index: i, ...enemies[i]}));
        }

        function handleInput(action) {
            // Safety Delay Check for Game Over
            if (gameState === 'GAMEOVER') {
                const now = Date.now();
                if (now - gameOverTime < 1000) return;
                resetGame();
                return;
            }

            // Start game from Menu
            if (gameState === 'MENU') {
                resetGame();
                return;
            }

            if (action === 'left') {
                player.dir = (player.dir + 3) % 4; // turn left
                draw(); updateOverlay();
            } else if (action === 'right') {
                player.dir = (player.dir + 1) % 4; // turn right
                draw(); updateOverlay();
            } else if (action === 'fire') {
                performFire();
                draw();
                updateOverlay();
            }
        }

        function performFire() {
            const weapon = weaponSelect.value;
            if (weapon === 'pistol') {
                const r = raycast(player.x, player.y, player.dir, tileCount);
                if (r) {
                    const e = enemies[r.index];
                    e.hp -= 1;
                    if (e.hp <= 0) {
                        enemies.splice(r.index, 1);
                        score += 1;
                        if (score > highScore) highScore = score;
                    }
                }
            } else if (weapon === 'shotgun') {
                // short range but can hit multiple enemies in a cone
                const hits = shotgunHits(player.x, player.y, player.dir, Math.max(2, Math.floor(tileCount/4)));
                // damage each once
                // sort indices descending to remove safely
                const indices = [...new Set(hits.map(h=>h.index))].sort((a,b)=>b-a);
                for (const idx of indices) {
                    if (!enemies[idx]) continue;
                    enemies[idx].hp -= 1;
                    if (enemies[idx].hp <= 0) {
                        enemies.splice(idx, 1);
                        score += 1;
                        if (score > highScore) highScore = score;
                    }
                }
            } else if (weapon === 'sniper') {
                const r = raycast(player.x, player.y, player.dir, tileCount);
                if (r) {
                    const e = enemies[r.index];
                    e.hp -= 3;
                    if (e.hp <= 0) {
                        enemies.splice(r.index, 1);
                        score += 1;
                        if (score > highScore) highScore = score;
                    }
                }
            }
        }

        // --- GAME UPDATE ---
        function update() {
            if (gameState !== 'PLAYING') return;

            // Move enemies towards player with some randomness
            for (let i = enemies.length - 1; i >= 0; i--) {
                const m = enemies[i];
                // simple pathing: move closer with chance
                if (Math.random() < 0.7) {
                    const dx = Math.sign(player.x - m.x);
                    const dy = Math.sign(player.y - m.y);
                    if (dx !== 0 && dy !== 0) {
                        if (Math.random() < 0.5) m.x += dx; else m.y += dy;
                    } else {
                        m.x += dx;
                        m.y += dy;
                    }
                } else {
                    // small random move to avoid perfectly predictable
                    if (Math.random() < 0.5) {
                        m.x += (Math.random() < 0.5 ? -1 : 1);
                    } else {
                        m.y += (Math.random() < 0.5 ? -1 : 1);
                    }
                }

                // clamp inside
                m.x = Math.max(0, Math.min(tileCount-1, m.x));
                m.y = Math.max(0, Math.min(tileCount-1, m.y));

                // check collision with player
                if (m.x === player.x && m.y === player.y) {
                    gameState = 'GAMEOVER';
                    gameOverTime = Date.now();
                    updateOverlay();
                    return;
                }
            }

            // respawn enemies slowly if all cleared
            if (enemies.length === 0) {
                placeEnemies(Math.min(enemyCount + Math.floor(score / 3), tileCount * 2));
            }
        }

        // --- DRAW ---
        function draw() {
            // Background
            ctx.fillStyle = 'black'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const gray = bgGrayValue;
            ctx.fillStyle = `rgb(${gray}, ${Math.max(0, gray-10)}, ${Math.max(0, gray-20)})`;
            ctx.fillRect(4, 4, canvas.width - 8, canvas.height - 8);

            if (gameState === 'MENU') {
                drawText("DOOM MINI", "PRESS PAUSE TO START");
                return;
            }

            if (gameState === 'GAMEOVER') {
                const now = Date.now();
                if (now - gameOverTime < 1000) {
                    drawText("YOU DIED", "WAIT...");
                } else {
                    drawText("YOU DIED", `SCORE: ${score}`);
                }
                return;
            }

            // grid drawing scaled to canvas size
            const cell = canvas.width / tileCount;

            // draw enemies
            for (let e of enemies) {
                // color based on hp
                if (e.hp >= 3) ctx.fillStyle = '#990000';
                else if (e.hp === 2) ctx.fillStyle = '#ff6666';
                else ctx.fillStyle = '#ff3333';
                ctx.fillRect(e.x * cell + 2, e.y * cell + 2, cell - 4, cell - 4);
                // hp text
                ctx.fillStyle = '#fff';
                ctx.font = `${Math.max(10, cell/3)}px Courier New`;
                ctx.textAlign = 'center';
                ctx.fillText(e.hp.toString(), e.x * cell + cell/2, e.y * cell + cell/2 + 4);
            }

            // draw player
            ctx.fillStyle = '#66ccff';
            ctx.fillRect(player.x * cell + 2, player.y * cell + 2, cell - 4, cell - 4);
            // gun indicator
            const pdx = player.dir === 0 ? 1 : player.dir === 2 ? -1 : 0;
            const pdy = player.dir === 1 ? 1 : player.dir === 3 ? -1 : 0;
            ctx.fillStyle = '#0066ff';
            ctx.fillRect((player.x + pdx) * cell + cell/2 - 5, (player.y + pdy) * cell + cell/2 - 5, 10, 10);

            // HUD
            ctx.fillStyle = '#fff';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 8, 16);
            ctx.fillText(`Best: ${highScore}`, 8, 30);
            ctx.fillText(`Gun: ${weaponSelect.value}`, 8, 44);
        }

        function drawText(line1, line2) {
            ctx.fillStyle = '#f40';
            ctx.font = 'bold 28px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(line1, canvas.width/2, canvas.height/2 - 10);
            ctx.fillText(line2, canvas.width/2, canvas.height/2 + 30);
        }

        // --- MEDIA SESSION / OVERLAY ---
        function updateOverlay() {
            if ('mediaSession' in navigator) {
                let titleText = `Score: ${score}`;
                let artistText = `High Score: ${highScore}`;

                if (gameState === 'MENU') {
                    titleText = "Doom: Windows Media Controls Edition";
                    artistText = "Use Prev/Next to TURN, Pause to FIRE";
                } else if (gameState === 'GAMEOVER') {
                    titleText = "YOU DIED";
                    artistText = `Final: ${score} | Best: ${highScore}`;
                }

                navigator.mediaSession.metadata = new MediaMetadata({
                    title: titleText,
                    artist: artistText,
                    artwork: [{ src: canvas.toDataURL('image/png'), sizes: '256x256', type: 'image/png' }]
                });
            }
        }

        // --- LOOPS ---
        function gameLoop() {
            update();
            draw();
            setTimeout(() => requestAnimationFrame(gameLoop), gameSpeed); 
        }

        setInterval(updateOverlay, 100); // keep metadata fresh

        // --- START BUTTON ---
        startBtn.onclick = () => {
            music.currentTime = 0;
            music.volume = 1.0; 
        
            music.play().then(() => {                
                setDifficulty();
                
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.playbackState = 'playing';
        
                    navigator.mediaSession.setActionHandler('previoustrack', () => handleInput('left'));
                    navigator.mediaSession.setActionHandler('nexttrack', () => handleInput('right'));
                    
                    // Map Pause to FIRE as requested
                    const handlePauseFire = () => {
                        handleInput('fire');
                        // keep music playing so the overlay remains present
                        music.play();
                        navigator.mediaSession.playbackState = 'playing';
                    };

                    // Only map pause to fire. Keep play default (or use play to resume music).
                    navigator.mediaSession.setActionHandler('pause', handlePauseFire);
                    // Optionally map 'play' to keep music alive without firing
                    navigator.mediaSession.setActionHandler('play', () => {
                        music.play();
                        navigator.mediaSession.playbackState = 'playing';
                    });
                    
                    updateOverlay();
                }
        
                gameLoop();
                startBtn.textContent = "LINK ACTIVE - OPEN WIN+A";
                startBtn.disabled = true;
            }).catch(err => {
                console.error("Audio playback failed:", err);
                alert("Audio Error: " + err.message);
            });
        };
    </script>
</body>
</html>
