<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Doom: Windows Media Controls Edition</title>

    <meta property="og:title" content="Doom: Windows Media Controls Edition">
    <meta property="og:description" content="Play a tiny doom-like shooter inside your Windows Media Controls overlay. Use Prev/Next to turn, Play/Pause to FIRE!">
    <meta property="og:image" content="https://thegoodjakeward.github.io/snake_windows_media_controls_edition/social.png">
    <meta property="og:url" content="https://thegoodjakeward.github.io/snake_windows_media_controls_edition/">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="https://thegoodjakeward.github.io/snake_windows_media_controls_edition/">
    <meta name="twitter:title" content="Doom: Windows Media Controls Edition">
    <meta name="twitter:description" content="Play a tiny doom-like shooter inside your Windows Media Controls overlay. Use Prev/Next to turn, Play/Pause to FIRE!">
    <meta name="twitter:image" content="https://thegoodjakeward.github.io/snake_windows_media_controls_edition/social.png">
    
    <style>
        body { 
            background: #111; 
            color: #eee; 
            font-family: 'Segoe UI', sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            height: 100vh; 
            margin: 0; 
        }
        
        h1 {
            margin: 0 0 20px 0;
            font-weight: 300;
            letter-spacing: 2px;
            color: #f40;
            text-transform: uppercase;
            text-align:center;
            text-shadow: 0 0 10px rgba(255, 64, 0, 0.25);
        }

        .panel {
            background: #222;
            padding: 2rem;
            border-radius: 8px;
            border: 1px solid #444;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            width: 350px;
        }

        button { 
            padding: 15px 30px; 
            font-size: 18px; 
            cursor: pointer; 
            background: #f40; 
            color: #000;
            border: none; 
            font-weight: bold; 
            border-radius: 4px; 
            margin-bottom: 20px;
            width: 100%;
        }
        button:hover { background: #d13a00; }
        button:disabled { background: #444; color: #888; cursor: not-allowed; }

        .settings-group {
            margin: 15px 0;
            text-align: left;
        }

        label { display: block; margin-bottom: 5px; font-weight: bold; }
        
        select {
            width: 100%;
            padding: 8px;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
        }

        .slider-container {
            margin-top: 20px;
            text-align: left;
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #444;
        }

        input[type=range] {
            width: 100%;
            margin-top: 5px;
            cursor: pointer;
        }

        .instructions { font-size: 0.9em; color: #aaa; margin-top: 20px; line-height: 1.5; }
    </style>
</head>
<body>

    <h1>Doom: Windows Media <br/>Controls Edition</h1>

    <div class="panel">
        <button id="startBtn">INITIALIZE SYSTEM LINK</button>
        
        <div class="settings-group">
            <label for="difficulty">Difficulty Level:</label>
            <select id="difficulty">
                <option value="casual" selected>Casual (8x8 Arena - Easier)</option>
                <option value="gamer">Gamer (16x16 Arena - Harder)</option>
            </select>
        </div>

        <div class="slider-container">
            <label for="bgSlider">Background Shade</label>
            <div style="font-size: 0.8em; color: #888; margin-bottom: 5px;">
                Use slider to tune the arena background shade.
            </div>
            <input type="range" id="bgSlider" min="0" max="255" value="0">
        </div>

        <div class="instructions">
            <p>1. Click Initialize above.</p>
            <p>2. Press <b>Win + A</b> to open Media Controls.</p>
            <p>3. Press <b>Prev (&#9198;)</b> or <b>Next (&#9197;)</b> to TURN left/right.</p>
            <p>4. Press <b>Play/Pause</b> to FIRE.</p>
        </div>
    </div>

    <audio id="bgMusic" loop src="music.mp3"></audio>

    <script>
        // --- 1. SETUP ---
        const canvas = document.createElement('canvas'); // create "headless" canvas
        canvas.width = 256;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');
        
        const startBtn = document.getElementById('startBtn');
        const music = document.getElementById('bgMusic');
        const difficultySelect = document.getElementById('difficulty');
        const bgSlider = document.getElementById('bgSlider');

        // Game State Variables
        let gameState = 'MENU'; 
        let highScore = 0;
        let score = 0;
        let player = null;
        let monsters = [];
        let bullets = [];
        let gameOverTime = 0; // Timestamp for death
        
        // Settings, initialized to default casual settings
        let tileCount = 8; 
        let gridSize = 32;
        let bgGrayValue = 0; // 0-255
        let gameSpeed = 1000 / 6;
        let monsterCount = 3;

        // --- 2. INPUT LISTENERS ---
        
        // Reset on difficulty change
        difficultySelect.onchange = () => {
            if (gameState === 'PLAYING') {
                gameState = 'GAMEOVER';
            } else {
                setDifficulty(); 
            }
        };

        // Real-time Background Update from Slider
        bgSlider.oninput = () => {
            bgGrayValue = parseInt(bgSlider.value);
            draw();
            updateOverlay();
        };

        // --- 3. LOGIC ---

        function setDifficulty() {
            const level = difficultySelect.value;
            if (level === 'casual') {
                tileCount = 8;
                gameSpeed = 1000 / 6;
                monsterCount = 3;
            } else if (level === 'gamer') {
                tileCount = 16;
                gameSpeed = 1000 / 8;
                monsterCount = 7;
            }
            gridSize = canvas.width / tileCount;
        }

        function resetGame() {
            setDifficulty();
            // Start player in middle
            const mid = Math.floor(tileCount / 2);
            player = {x: mid, y: mid, dir: 0}; // dir: 0=right,1=down,2=left,3=up
            monsters = [];
            bullets = [];
            score = 0;
            placeMonsters(monsterCount);
            gameState = 'PLAYING';
            draw();
            updateOverlay();
        }

        function placeMonsters(n) {
            monsters = [];
            let attempts = 0;
            while (monsters.length < n && attempts < 500) {
                const mx = Math.floor(Math.random() * tileCount);
                const my = Math.floor(Math.random() * tileCount);
                // avoid placing on player
                if (mx === player.x && my === player.y) { attempts++; continue; }
                let conflict = false;
                for (let m of monsters) {
                    if (m.x === mx && m.y === my) { conflict = true; break; }
                }
                if (!conflict) monsters.push({x: mx, y: my});
                attempts++;
            }
        }

        function handleInput(action) {
            // Safety Delay Check for Game Over
            if (gameState === 'GAMEOVER') {
                const now = Date.now();
                if (now - gameOverTime < 1000) {
                    return;
                }
                resetGame();
                return;
            }

            // Start game from Menu
            if (gameState === 'MENU') {
                resetGame();
                return;
            }

            if (action === 'left') {
                player.dir = (player.dir + 3) % 4; // turn left
            } else if (action === 'right') {
                player.dir = (player.dir + 1) % 4; // turn right
            } else if (action === 'fire') {
                // spawn bullet in front of player
                const dir = player.dir;
                const dx = dir === 0 ? 1 : dir === 2 ? -1 : 0;
                const dy = dir === 1 ? 1 : dir === 3 ? -1 : 0;
                bullets.push({x: player.x + dx, y: player.y + dy, dx, dy});
            }
        }

        function update() {
            if (gameState !== 'PLAYING') return;

            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.x += b.dx;
                b.y += b.dy;
                // remove if out of bounds
                if (b.x < 0 || b.x >= tileCount || b.y < 0 || b.y >= tileCount) {
                    bullets.splice(i, 1);
                    continue;
                }
                // check collision with monsters
                for (let j = monsters.length - 1; j >= 0; j--) {
                    const m = monsters[j];
                    if (m.x === b.x && m.y === b.y) {
                        monsters.splice(j, 1);
                        bullets.splice(i, 1);
                        score += 1;
                        if (score > highScore) highScore = score;
                        break;
                    }
                }
            }

            // Move monsters one step toward player
            for (let m of monsters) {
                const dx = Math.sign(player.x - m.x);
                const dy = Math.sign(player.y - m.y);
                // prefer horizontal or vertical move randomly if both non-zero
                if (dx !== 0 && dy !== 0) {
                    if (Math.random() < 0.5) m.x += dx; else m.y += dy;
                } else {
                    m.x += dx;
                    m.y += dy;
                }
                // clamp wrap not allowed for monsters; keep inside
                if (m.x < 0) m.x = 0;
                if (m.x >= tileCount) m.x = tileCount - 1;
                if (m.y < 0) m.y = 0;
                if (m.y >= tileCount) m.y = tileCount - 1;
                // check collision with player
                if (m.x === player.x && m.y === player.y) {
                    gameState = 'GAMEOVER';
                    gameOverTime = Date.now();
                    updateOverlay();
                    return;
                }
            }

            // respawn monsters slowly if all cleared
            if (monsters.length === 0) {
                placeMonsters(Math.min(monsterCount + Math.floor(score / 3), tileCount * 2));
            }
        }

        function draw() {
            // Draw Background (Using Slider Value)
            ctx.fillStyle = 'black'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const gray = bgGrayValue;
            ctx.fillStyle = `rgb(${gray}, ${Math.max(0, gray-10)}, ${Math.max(0, gray-20)})`;
            ctx.fillRect(4, 4, canvas.width - 8, canvas.height - 8);

            // State Drawing
            if (gameState === 'MENU') {
                drawText("DOOM MINI", "PRESS KEY TO START");
                return;
            }

            if (gameState === 'GAMEOVER') {
                // Show "WAIT..." if in the safety lockout period
                const now = Date.now();
                if (now - gameOverTime < 1000) {
                    drawText("YOU DIED", "WAIT...");
                } else {
                    drawText("YOU DIED", `SCORE: ${score}`);
                }
                return;
            }

            // Draw grid elements
            // Draw monsters
            for (let m of monsters) {
                ctx.fillStyle = '#ff3333';
                ctx.fillRect(m.x * gridSize + 2, m.y * gridSize + 2, gridSize - 4, gridSize - 4);
            }

            // Draw bullets
            for (let b of bullets) {
                ctx.fillStyle = '#ffff66';
                ctx.fillRect(b.x * gridSize + gridSize/2 - 2, b.y * gridSize + gridSize/2 - 2, 4, 4);
            }

            // Draw player
            ctx.fillStyle = '#66ccff';
            ctx.fillRect(player.x * gridSize + 2, player.y * gridSize + 2, gridSize - 4, gridSize - 4);
            // Draw gun indicator as small rectangle in front of player
            const pdx = player.dir === 0 ? 1 : player.dir === 2 ? -1 : 0;
            const pdy = player.dir === 1 ? 1 : player.dir === 3 ? -1 : 0;
            ctx.fillStyle = '#0066ff';
            ctx.fillRect((player.x + pdx) * gridSize + gridSize/2 - 4, (player.y + pdy) * gridSize + gridSize/2 - 4, 8, 8);

            // HUD (small)
            ctx.fillStyle = '#fff';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 8, 16);
            ctx.fillText(`Best: ${highScore}`, 8, 30);
        }

        function drawText(line1, line2) {
            ctx.fillStyle = '#f40';
            ctx.font = 'bold 28px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(line1, canvas.width/2, canvas.height/2 - 10);
            ctx.fillText(line2, canvas.width/2, canvas.height/2 + 30);
        }

        function updateOverlay() {
            if ('mediaSession' in navigator) {
                let titleText = `Score: ${score}`;
                let artistText = `High Score: ${highScore}`;

                if (gameState === 'MENU') {
                    titleText = "Doom: Windows Media Controls Edition";
                    artistText = "Press Prev/Next to TURN, Play/Pause to FIRE";
                } else if (gameState === 'GAMEOVER') {
                    titleText = "YOU DIED";
                    artistText = `Final: ${score} | Best: ${highScore}`;
                }

                navigator.mediaSession.metadata = new MediaMetadata({
                    title: titleText,
                    artist: artistText,
                    artwork: [{ src: canvas.toDataURL('image/png'), sizes: '256x256', type: 'image/png' }] // pushes current game screen to album art
                });
            }
        }

        // --- 4. LOOPS ---

        function gameLoop() {
            update();
            draw();
            setTimeout(() => requestAnimationFrame(gameLoop), gameSpeed); 
        }

        setInterval(updateOverlay, 50); // update metadata periodically

        startBtn.onclick = () => {
            // Reset and Prep Music
            music.currentTime = 0;
            music.volume = 1.0; 
        
            music.play().then(() => {                
                setDifficulty();
                
                if ('mediaSession' in navigator) {
                    // Force the playback state to 'playing' so Windows notices
                    navigator.mediaSession.playbackState = 'playing';
        
                    navigator.mediaSession.setActionHandler('previoustrack', () => handleInput('left'));
                    navigator.mediaSession.setActionHandler('nexttrack', () => handleInput('right'));
                    
                    // Map Play/Pause to FIRE
                    const handleFire = () => {
                        handleInput('fire');
                        music.play(); // keep music playing
                        navigator.mediaSession.playbackState = 'playing';
                    };
        
                    navigator.mediaSession.setActionHandler('play', handleFire);
                    navigator.mediaSession.setActionHandler('pause', handleFire);
                    
                    // Initial overlay update to "kick" Windows into showing the UI
                    updateOverlay();
                }
        
                gameLoop();
                startBtn.textContent = "LINK ACTIVE - OPEN WIN+A";
                startBtn.disabled = true;
            }).catch(err => {
                console.error("Audio playback failed:", err);
                alert("Audio Error: " + err.message);
            });
        };
    </script>
</body>
</html>
